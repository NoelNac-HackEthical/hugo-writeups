name: Sync mes-scripts (changed-only, no prune)

on:
  repository_dispatch:
    types: [mes-scripts-release]

permissions:
  contents: write
  pull-requests: read

jobs:
  sync:
    runs-on: ubuntu-latest

    env:
      TARGET_BRANCH: ${{ vars.TARGET_BRANCH }}
      DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
      PAYLOAD_TARGET_BRANCH: ${{ github.event.client_payload.target_branch || '' }}
      PR_BRANCH: ${{ github.head_ref || '' }}

    steps:
      # -------- Resolve target branch (PR > payload > var > default)
      - name: Resolve target branch
        shell: bash
        run: |
          set -euo pipefail
          TB="${TARGET_BRANCH:-}"
          PB="${PAYLOAD_TARGET_BRANCH:-}"
          PR="${PR_BRANCH:-}"
          DB="${DEFAULT_BRANCH:-master}"
          BR="${PR:-${PB:-${TB:-$DB}}}"
          echo "PR_BRANCH='${PR:-<empty>}'  PAYLOAD_TARGET_BRANCH='${PB:-<empty>}'  TARGET_BRANCH='${TB:-<empty>}'  DEFAULT_BRANCH='${DB}'  =>  BRANCH='${BR}'"
          echo "BRANCH=${BR}" >> "$GITHUB_ENV"

      - name: Checkout site
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare branch working tree
        shell: bash
        run: |
          set -euo pipefail
          git fetch --all --prune
          if git ls-remote --exit-code --heads origin "${BRANCH}" >/dev/null 2>&1; then
            git checkout -B "${BRANCH}" "origin/${BRANCH}"
          else
            git checkout -B "${BRANCH}" "origin/${DEFAULT_BRANCH}"
          fi
          echo "--- branch ready on ${BRANCH} ---"

      # -------- Payload (sans heredoc, via env)
      - name: Read payload (repository_dispatch)
        id: payload
        shell: bash
        env:
          PAYLOAD_JSON: ${{ toJson(github.event.client_payload) }}
        run: |
          set -euo pipefail
          printf '%s' "$PAYLOAD_JSON" > payload.json || true
          if [ ! -s payload.json ]; then
            echo '{}' > payload.json
            echo "::warning ::payload.json était vide, stub {} écrit."
          fi
          echo "payload.json written"

      - name: Show payload snippet (optional)
        shell: bash
        run: |
          set -euo pipefail
          if command -v jq >/dev/null 2>&1; then
            jq -c '{keys:(keys), scope, scripts, assets_len:(.assets|keys|length)}' payload.json || true
          else
            echo "jq not installed; skipping snippet."
          fi

      # -------- Content generation
      - name: Ensure work dirs
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p content/mes-scripts
          mkdir -p content/mes-scripts/_index
          mkdir -p assets/mes-scripts || true

      - name: Extract fields from payload
        id: extract
        shell: bash
        run: |
          set -euo pipefail
          command -v jq >/dev/null 2>&1 || { echo "jq required"; exit 1; }
          SCOPE="$(jq -r '.scope // "auto"' payload.json)"
          echo "scope=$SCOPE" >> "$GITHUB_OUTPUT"
          jq -r '.scripts[]?' payload.json > scripts.list || true
          jq -c '.assets' payload.json > assets.json || echo '{}' > assets.json
          echo "Scripts list:"; cat scripts.list || true

      - name: Update section _index.md
        shell: bash
        run: |
          set -euo pipefail
          INDEX="content/mes-scripts/_index.md"
          if [ ! -f "$INDEX" ]; then
            printf '%s\n' \
              '---' \
              'title: "Mes scripts"' \
              'description: "Catalogue synchronisé automatiquement depuis le dépôt mes-scripts"' \
              '---' > "$INDEX"
          fi
          echo "section _index.md OK"

      - name: Build/update each script bundle (only selected)
        shell: bash
        run: |
          set -euo pipefail
          command -v jq >/dev/null 2>&1 || { echo "jq required"; exit 1; }

          ASSETS="assets.json"
          [ -s "$ASSETS" ] || echo "{}" > "$ASSETS"

          # 1) Liste des scripts à traiter
          has_list=false
          if [ -s scripts.list ] && grep -q '[^[:space:]]' scripts.list; then
            has_list=true
          fi

          if $has_list; then
            mapfile -t TO_BUILD < <(
              awk 'NF' scripts.list \
              | while read -r s; do
                  if jq -e --arg k "$s" 'has($k)' "$ASSETS" >/dev/null; then
                    echo "$s"
                  else
                    echo "::warning ::script '$s' absent des assets → ignoré" >&2
                  fi
                done
            )
          else
            mapfile -t TO_BUILD < <(jq -r 'keys[]?' "$ASSETS" 2>/dev/null || true)
          fi

          if [ ${#TO_BUILD[@]} -eq 0 ]; then
            echo "::notice ::Aucun bundle à (re)générer."
            exit 0
          fi

          echo "Bundles à (re)générer:"
          printf ' - %s\n' "${TO_BUILD[@]}"

          # 2) Génération des bundles sélectionnés
          for s in "${TO_BUILD[@]}"; do
            name="$(basename "$s")"
            base="${name}"
            dir="content/mes-scripts/${base%.*}"
            mkdir -p "$dir"

            url="$(jq -r --arg k "$s" '.[$k].url // empty' "$ASSETS")"
            sha="$(jq -r --arg k "$s" '.[$k].sha256 // empty' "$ASSETS")"
            ver="$(jq -r --arg k "$s" '.[$k].version // empty' "$ASSETS")"

            # --- Normalisation de la version : isole un numéro propre (ex: 1.0.0, v1.2, 2.3.4-rc1)
            ver_raw="$ver"
            if [[ "$ver_raw" =~ ([vV]?[0-9]+(\.[0-9]+){1,3}([._-]?(alpha|beta|rc)[0-9]*)?) ]]; then
              ver_num="${BASH_REMATCH[1]}"
            else
              # Secours : prend le dernier token après espace (si "mon-nmap 1.0.0")
              ver_num="${ver_raw##* }"
            fi

            desc="$(jq -r --arg k "$s" '.[$k].description // empty' "$ASSETS")"
            usage="$(jq -r --arg k "$s" '.[$k].usage // empty' "$ASSETS")"
            pres="$(jq -r --arg k "$s" '.[$k].presentation_md // empty' "$ASSETS")"
            repo="$(jq -r '.source_repo // "NoelNac-HackEthical/mes-scripts"' payload.json 2>/dev/null || echo "NoelNac-HackEthical/mes-scripts")"

            # Si un jour on transporte un titre explicite dans le payload (.assets[script].title)
            title_raw="$(jq -r --arg k "$s" '.[$k].title // empty' "$ASSETS")"
            if [ -n "$title_raw" ] && [ "$title_raw" != "null" ]; then
              title="$title_raw"
            else
              # Humanize: test-script-03 -> Test Script 03
              title="$(printf '%s' "$base" | sed -E 's/[-_]+/ /g' | awk '{for(i=1;i<=NF;i++){ $i=toupper(substr($i,1,1)) tolower(substr($i,2)) } print}')"
            fi

            INDEX="${dir}/index.md"

            {
              printf '%s\n' '---'
              printf 'title: "%s"\n'        "$title"
              printf 'slug: "%s"\n'         "$base"
              printf 'description: "%s"\n'  "$desc"
              printf '%s\n' 'draft: false'
              printf '%s\n' 'tags: ["scripts","tools"]'
              printf '%s\n' 'categories: ["Mes scripts"]'
              printf '%s\n' 'showIntro: false'
              printf '%s\n' 'cover:'
              printf '%s\n' '  hidden: true'
              printf '%s\n' '  hiddenInSingle: true'
              printf 'repo: "%s"\n'         "$repo"
              printf 'script_file: "%s"\n'  "$base"
              printf 'version: "%s"\n'      "$ver"
              printf '%s\n\n' '---'

              # DESCRIPTION
              if [ -n "$desc" ] && [ "$desc" != "null" ]; then
                printf '%s\n\n' "$desc"
              fi

              # Présentation
              if [ -n "$pres" ] && [ "$pres" != "null" ]; then
                printf '## Présentation\n\n%s\n\n' "$pres"
              fi

              # Usage (bloc code)
              if [ -n "$usage" ] && [ "$usage" != "null" ]; then
                printf '## Usage\n\n```\n%s\n```\n\n' "$usage"
              fi

              # Téléchargements (styled + releases/latest)
              printf '%s\n\n' '## Téléchargements'
              printf 'La version courante du script %s est %s\n\n' "${base%.*}" "$ver_num"
              printf '%s\n' '<div class="dl-row" style="display:flex; gap:.6rem; align-items:center; flex-wrap:wrap">'
              printf '%s\n' "  {{< btn href=\"https://github.com/${repo}/releases/latest/download/${base}\" text=\"Télécharger la version courante\" class=\"he-btn--neutral\" >}}"
              printf '%s\n' "  {{< btn href=\"https://github.com/${repo}/releases/latest/download/${base}.sha256\" text=\"SHA256\" class=\"he-btn--sm he-btn--neutral\" >}}"
              printf '%s\n\n' '</div>'
            } > "$INDEX"

            echo "Updated bundle: $INDEX"
          done

      # -------- Upsert via API Contents (no local push)
      - name: Commit via API contents (create/update) — changed files only
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          BRANCH: ${{ env.BRANCH }}
        shell: bash
        run: |
          set -euo pipefail
          command -v jq >/dev/null 2>&1 || { echo "jq required"; exit 1; }

          # Liste robuste des fichiers modifiés ET non-trackés (fichiers uniquement)
          changed_files=$(git ls-files -mo --exclude-standard)

          if [ -z "$changed_files" ]; then
            echo "No local changes to commit via API."
            exit 0
          fi

          for f in $changed_files; do
            if [ ! -f "$f" ]; then
              echo "::notice ::Skipping non-file $f"
              continue
            fi
            api="https://api.github.com/repos/${REPO}/contents/${f}"
            sha=$(curl -sS -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
                  "$api?ref=${BRANCH}" | jq -r '.sha // empty')
            b64=$(base64 -w0 "$f")
            msg="chore(sync): update ${f}"

            if [ -n "$sha" ]; then
              data=$(jq -nc --arg m "$msg" --arg c "$b64" --arg b "$BRANCH" --arg s "$sha" \
                      '{message:$m, content:$c, branch:$b, sha:$s}')
            else
              data=$(jq -nc --arg m "$msg" --arg c "$b64" --arg b "$BRANCH" \
                      '{message:$m, content:$c, branch:$b}')
            fi

            code=$(curl -sS -o /tmp/resp.json -w '%{http_code}' -X PUT \
                    -H "Authorization: Bearer ${GH_TOKEN}" \
                    -H "Accept: application/vnd.github+json" \
                    "$api" -d "$data")
            echo "[$code] upsert $f"
            test "$code" -ge 200 -a "$code" -lt 300
          done

      - name: Cleanup temp files
        shell: bash
        run: |
          rm -f payload.json || true

      - name: Verify remote tip after API upserts (no push)
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin "${BRANCH}" --prune
          echo "Remote tip:"
          git ls-remote origin "refs/heads/${BRANCH}"
